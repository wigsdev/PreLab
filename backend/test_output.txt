============================= test session starts =============================
platform win32 -- Python 3.13.7, pytest-8.4.2, pluggy-1.6.0 -- C:\Python313\python.exe
cachedir: .pytest_cache
django: version: 6.0.1, settings: config.settings (from ini)
rootdir: C:\Users\WIGUSA\Documents\GitHub\PreLab\backend
configfile: pytest.ini
plugins: anyio-4.11.0, cov-7.0.0, django-4.11.1
collecting ... collected 8 items

core/tests/test_models.py::TestCoreModels::test_course_creation PASSED   [ 12%]
core/tests/test_models.py::TestCoreModels::test_topic_creation PASSED    [ 25%]
core/tests/test_models.py::TestCoreModels::test_question_creation FAILED [ 37%]
core/tests/test_models.py::TestCoreModels::test_exam_attempt_logic FAILED [ 50%]
core/tests/test_models.py::TestCoreModels::test_exam_answer_creation FAILED [ 62%]
core/tests/test_views.py::TestExamAttemptViewSet::test_list_exams_authenticated FAILED [ 75%]
core/tests/test_views.py::TestExamAttemptViewSet::test_create_exam_attempt FAILED [ 87%]
core/tests/test_views.py::TestExamAttemptViewSet::test_retrieve_exam_with_missing_data_safe FAILED [100%]

================================== FAILURES ===================================
____________________ TestCoreModels.test_question_creation ____________________

self = <test_models.TestCoreModels object at 0x0000029C1FAF08A0>

    def test_question_creation(self):
        course = Course.objects.create(name="Physics", code="PHYS101")
        topic = Topic.objects.create(course=course, name="Kinematics")
>       question = Question.objects.create(
            topic=topic,
            statement="What is velocity?",
            correct_option="A",
            option_a="Speed with direction",
            option_b="Just speed",
            option_c="Distance",
            option_d="Time",
            option_e="None"
        )

core\tests\test_models.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Python313\Lib\site-packages\django\db\models\query.py:667: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Question: [PHYS101] What is velocity?...>, args = ()
kwargs = {'correct_option': 'A', 'option_a': 'Speed with direction', 'option_b': 'Just speed', 'option_c': 'Distance', ...}
cls = <class 'core.models.Question'>, opts = <Options for Question>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x0000029C1FB7C280>, val = None
field = <django.db.models.fields.DateTimeField: created_at>
is_related_object = False, rel_obj = <Topic: Physics - Kinematics>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then
        # args overrides it. It should be one or the other; don't duplicate the
        # work The reason for the kwargs check is that standard iterator passes
        # in by args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the
            # second is *not* consumed. We rely on this, so don't change the
            # order without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an
                            # ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: Question() got unexpected keyword arguments: 'correct_option', 'option_a', 'option_b', 'option_c', 'option_d', 'option_e'

C:\Python313\Lib\site-packages\django\db\models\base.py:590: TypeError
___________________ TestCoreModels.test_exam_attempt_logic ____________________

self = <django.db.backends.utils.CursorWrapper object at 0x0000029C1FCAF290>
sql = 'INSERT INTO "core_examattempt" ("user_id", "course_id", "topic_id", "exam_type", "score", "correct_count", "total_questions", "created_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s) RETURNING "core_examattempt"."id"'
params = (1, 1, None, 'COURSE', 15.0, None, ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x0000029C1FCAF290>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Python313\Lib\site-packages\django\db\backends\utils.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000029C1FE7BA40>
query = 'INSERT INTO "core_examattempt" ("user_id", "course_id", "topic_id", "exam_type", "score", "correct_count", "total_questions", "created_at") VALUES (?, ?, ?, ?, ?, ?, ?, ?) RETURNING "core_examattempt"."id"'
params = (1, 1, None, 'COURSE', 15.0, None, ...)

    def execute(self, query, params=None):
        if params is None:
            return super().execute(query)
        # Extract names if params is a mapping, i.e. "pyformat" style is used.
        param_names = list(params) if isinstance(params, Mapping) else None
        query = self.convert_query(query, param_names=param_names)
>       return super().execute(query, params)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlite3.IntegrityError: NOT NULL constraint failed: core_examattempt.correct_count

C:\Python313\Lib\site-packages\django\db\backends\sqlite3\base.py:359: IntegrityError

The above exception was the direct cause of the following exception:

self = <test_models.TestCoreModels object at 0x0000029C1FAF0C30>
student_user = <CustomUser: student@test.com>

    def test_exam_attempt_logic(self, student_user):
        """Test that an exam attempt can be created and linked to a user"""
        course = Course.objects.create(name="Chemistry", code="CHEM101")
>       attempt = ExamAttempt.objects.create(
            user=student_user,
            course=course,
            score=15,
            total_questions=20
        )

core\tests\test_models.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Python313\Lib\site-packages\django\db\models\query.py:669: in create
    obj.save(force_insert=True, using=self.db)
C:\Python313\Lib\site-packages\django\db\models\base.py:874: in save
    self.save_base(
C:\Python313\Lib\site-packages\django\db\models\base.py:966: in save_base
    updated = self._save_table(
C:\Python313\Lib\site-packages\django\db\models\base.py:1167: in _save_table
    results = self._do_insert(
C:\Python313\Lib\site-packages\django\db\models\base.py:1218: in _do_insert
    return manager._insert(
C:\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Python313\Lib\site-packages\django\db\models\query.py:1918: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Python313\Lib\site-packages\django\db\models\sql\compiler.py:1925: in execute_sql
    cursor.execute(sql, params)
C:\Python313\Lib\site-packages\django\db\backends\utils.py:79: in execute
    return self._execute_with_wrappers(
C:\Python313\Lib\site-packages\django\db\backends\utils.py:92: in _execute_with_wrappers
    return executor(sql, params, many, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Python313\Lib\site-packages\django\db\backends\utils.py:100: in _execute
    with self.db.wrap_database_errors:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Python313\Lib\site-packages\django\db\utils.py:94: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
C:\Python313\Lib\site-packages\django\db\backends\utils.py:105: in _execute
    return self.cursor.execute(sql, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000029C1FE7BA40>
query = 'INSERT INTO "core_examattempt" ("user_id", "course_id", "topic_id", "exam_type", "score", "correct_count", "total_questions", "created_at") VALUES (?, ?, ?, ?, ?, ?, ?, ?) RETURNING "core_examattempt"."id"'
params = (1, 1, None, 'COURSE', 15.0, None, ...)

    def execute(self, query, params=None):
        if params is None:
            return super().execute(query)
        # Extract names if params is a mapping, i.e. "pyformat" style is used.
        param_names = list(params) if isinstance(params, Mapping) else None
        query = self.convert_query(query, param_names=param_names)
>       return super().execute(query, params)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       django.db.utils.IntegrityError: NOT NULL constraint failed: core_examattempt.correct_count

C:\Python313\Lib\site-packages\django\db\backends\sqlite3\base.py:359: IntegrityError
__________________ TestCoreModels.test_exam_answer_creation ___________________

self = <test_models.TestCoreModels object at 0x0000029C1FA83530>
student_user = <CustomUser: student@test.com>

    def test_exam_answer_creation(self, student_user):
        """Test linking specific answers to an attempt"""
        course = Course.objects.create(name="Biology", code="BIO101")
        topic = Topic.objects.create(course=course, name="Cells")
>       question = Question.objects.create(topic=topic, statement="Powerhouse of the cell?", correct_option="C")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

core\tests\test_models.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Python313\Lib\site-packages\django\db\models\query.py:667: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Question: [BIO101] Powerhouse of the cell?...>, args = ()
kwargs = {'correct_option': 'C'}, cls = <class 'core.models.Question'>
opts = <Options for Question>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x0000029C1FD52620>, val = None
field = <django.db.models.fields.DateTimeField: created_at>
is_related_object = False, rel_obj = <Topic: Biology - Cells>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then
        # args overrides it. It should be one or the other; don't duplicate the
        # work The reason for the kwargs check is that standard iterator passes
        # in by args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the
            # second is *not* consumed. We rely on this, so don't change the
            # order without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an
                            # ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: Question() got unexpected keyword arguments: 'correct_option'

C:\Python313\Lib\site-packages\django\db\models\base.py:590: TypeError
____________ TestExamAttemptViewSet.test_list_exams_authenticated _____________

self = <django.db.backends.utils.CursorWrapper object at 0x0000029C1FE8BA10>
sql = 'INSERT INTO "core_examattempt" ("user_id", "course_id", "topic_id", "exam_type", "score", "correct_count", "total_questions", "created_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s) RETURNING "core_examattempt"."id"'
params = (1, 1, None, 'COURSE', 10.0, None, ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x0000029C1FE8BA10>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Python313\Lib\site-packages\django\db\backends\utils.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000029C2024D9A0>
query = 'INSERT INTO "core_examattempt" ("user_id", "course_id", "topic_id", "exam_type", "score", "correct_count", "total_questions", "created_at") VALUES (?, ?, ?, ?, ?, ?, ?, ?) RETURNING "core_examattempt"."id"'
params = (1, 1, None, 'COURSE', 10.0, None, ...)

    def execute(self, query, params=None):
        if params is None:
            return super().execute(query)
        # Extract names if params is a mapping, i.e. "pyformat" style is used.
        param_names = list(params) if isinstance(params, Mapping) else None
        query = self.convert_query(query, param_names=param_names)
>       return super().execute(query, params)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlite3.IntegrityError: NOT NULL constraint failed: core_examattempt.correct_count

C:\Python313\Lib\site-packages\django\db\backends\sqlite3\base.py:359: IntegrityError

The above exception was the direct cause of the following exception:

self = <test_views.TestExamAttemptViewSet object at 0x0000029C1FB3C2D0>
auth_client = <rest_framework.test.APIClient object at 0x0000029C1FBC17F0>
student_user = <CustomUser: student@test.com>

    def test_list_exams_authenticated(self, auth_client, student_user):
        """Verify student can only see their own exams"""
        # Create exam for this student
        course = Course.objects.create(name="Math", code="M1")
>       ExamAttempt.objects.create(user=student_user, course=course, score=10)

core\tests\test_views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Python313\Lib\site-packages\django\db\models\query.py:669: in create
    obj.save(force_insert=True, using=self.db)
C:\Python313\Lib\site-packages\django\db\models\base.py:874: in save
    self.save_base(
C:\Python313\Lib\site-packages\django\db\models\base.py:966: in save_base
    updated = self._save_table(
C:\Python313\Lib\site-packages\django\db\models\base.py:1167: in _save_table
    results = self._do_insert(
C:\Python313\Lib\site-packages\django\db\models\base.py:1218: in _do_insert
    return manager._insert(
C:\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Python313\Lib\site-packages\django\db\models\query.py:1918: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Python313\Lib\site-packages\django\db\models\sql\compiler.py:1925: in execute_sql
    cursor.execute(sql, params)
C:\Python313\Lib\site-packages\django\db\backends\utils.py:79: in execute
    return self._execute_with_wrappers(
C:\Python313\Lib\site-packages\django\db\backends\utils.py:92: in _execute_with_wrappers
    return executor(sql, params, many, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Python313\Lib\site-packages\django\db\backends\utils.py:100: in _execute
    with self.db.wrap_database_errors:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Python313\Lib\site-packages\django\db\utils.py:94: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
C:\Python313\Lib\site-packages\django\db\backends\utils.py:105: in _execute
    return self.cursor.execute(sql, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000029C2024D9A0>
query = 'INSERT INTO "core_examattempt" ("user_id", "course_id", "topic_id", "exam_type", "score", "correct_count", "total_questions", "created_at") VALUES (?, ?, ?, ?, ?, ?, ?, ?) RETURNING "core_examattempt"."id"'
params = (1, 1, None, 'COURSE', 10.0, None, ...)

    def execute(self, query, params=None):
        if params is None:
            return super().execute(query)
        # Extract names if params is a mapping, i.e. "pyformat" style is used.
        param_names = list(params) if isinstance(params, Mapping) else None
        query = self.convert_query(query, param_names=param_names)
>       return super().execute(query, params)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       django.db.utils.IntegrityError: NOT NULL constraint failed: core_examattempt.correct_count

C:\Python313\Lib\site-packages\django\db\backends\sqlite3\base.py:359: IntegrityError
_______________ TestExamAttemptViewSet.test_create_exam_attempt _______________

self = <test_views.TestExamAttemptViewSet object at 0x0000029C1FB3C410>
auth_client = <rest_framework.test.APIClient object at 0x0000029C1FDAE990>
student_user = <CustomUser: student@test.com>

    def test_create_exam_attempt(self, auth_client, student_user):
        """Verify full flow of submitting an exam"""
        course = Course.objects.create(name="Physics", code="P1")
        topic = Topic.objects.create(course=course, name="Forces")
>       q1 = Question.objects.create(topic=topic, statement="F=ma?", correct_option="A", option_a="Yes", option_b="No", option_c="Maybe", option_d="Never", option_e="Who knows")
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

core\tests\test_views.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Python313\Lib\site-packages\django\db\models\query.py:667: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Question: [P1] F=ma?...>, args = ()
kwargs = {'correct_option': 'A', 'option_a': 'Yes', 'option_b': 'No', 'option_c': 'Maybe', ...}
cls = <class 'core.models.Question'>, opts = <Options for Question>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x0000029C1FDD7EE0>, val = None
field = <django.db.models.fields.DateTimeField: created_at>
is_related_object = False, rel_obj = <Topic: Physics - Forces>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then
        # args overrides it. It should be one or the other; don't duplicate the
        # work The reason for the kwargs check is that standard iterator passes
        # in by args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the
            # second is *not* consumed. We rely on this, so don't change the
            # order without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an
                            # ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: Question() got unexpected keyword arguments: 'correct_option', 'option_a', 'option_b', 'option_c', 'option_d', 'option_e'

C:\Python313\Lib\site-packages\django\db\models\base.py:590: TypeError
______ TestExamAttemptViewSet.test_retrieve_exam_with_missing_data_safe _______

self = <django.db.backends.utils.CursorWrapper object at 0x0000029C2064BA70>
sql = 'INSERT INTO "core_examattempt" ("user_id", "course_id", "topic_id", "exam_type", "score", "correct_count", "total_questions", "created_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s) RETURNING "core_examattempt"."id"'
params = (1, 1, None, 'COURSE', 0.0, None, ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x0000029C2064BA70>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Python313\Lib\site-packages\django\db\backends\utils.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000029C1FE7B380>
query = 'INSERT INTO "core_examattempt" ("user_id", "course_id", "topic_id", "exam_type", "score", "correct_count", "total_questions", "created_at") VALUES (?, ?, ?, ?, ?, ?, ?, ?) RETURNING "core_examattempt"."id"'
params = (1, 1, None, 'COURSE', 0.0, None, ...)

    def execute(self, query, params=None):
        if params is None:
            return super().execute(query)
        # Extract names if params is a mapping, i.e. "pyformat" style is used.
        param_names = list(params) if isinstance(params, Mapping) else None
        query = self.convert_query(query, param_names=param_names)
>       return super().execute(query, params)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlite3.IntegrityError: NOT NULL constraint failed: core_examattempt.correct_count

C:\Python313\Lib\site-packages\django\db\backends\sqlite3\base.py:359: IntegrityError

The above exception was the direct cause of the following exception:

self = <test_views.TestExamAttemptViewSet object at 0x0000029C1FAF0B00>
auth_client = <rest_framework.test.APIClient object at 0x0000029C1FDAEAD0>
student_user = <CustomUser: student@test.com>

    def test_retrieve_exam_with_missing_data_safe(self, auth_client, student_user):
        """
        REGRESSION TEST for 500 Bug.
        Verify that retrieving an exam with missing relations (e.g., deleted question)
        returns 200/400 but NOT 500.
        """
        course = Course.objects.create(name="Buggy Course", code="B1")
>       attempt = ExamAttempt.objects.create(user=student_user, course=course, score=0)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

core\tests\test_views.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Python313\Lib\site-packages\django\db\models\query.py:669: in create
    obj.save(force_insert=True, using=self.db)
C:\Python313\Lib\site-packages\django\db\models\base.py:874: in save
    self.save_base(
C:\Python313\Lib\site-packages\django\db\models\base.py:966: in save_base
    updated = self._save_table(
C:\Python313\Lib\site-packages\django\db\models\base.py:1167: in _save_table
    results = self._do_insert(
C:\Python313\Lib\site-packages\django\db\models\base.py:1218: in _do_insert
    return manager._insert(
C:\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Python313\Lib\site-packages\django\db\models\query.py:1918: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Python313\Lib\site-packages\django\db\models\sql\compiler.py:1925: in execute_sql
    cursor.execute(sql, params)
C:\Python313\Lib\site-packages\django\db\backends\utils.py:79: in execute
    return self._execute_with_wrappers(
C:\Python313\Lib\site-packages\django\db\backends\utils.py:92: in _execute_with_wrappers
    return executor(sql, params, many, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Python313\Lib\site-packages\django\db\backends\utils.py:100: in _execute
    with self.db.wrap_database_errors:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Python313\Lib\site-packages\django\db\utils.py:94: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
C:\Python313\Lib\site-packages\django\db\backends\utils.py:105: in _execute
    return self.cursor.execute(sql, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000029C1FE7B380>
query = 'INSERT INTO "core_examattempt" ("user_id", "course_id", "topic_id", "exam_type", "score", "correct_count", "total_questions", "created_at") VALUES (?, ?, ?, ?, ?, ?, ?, ?) RETURNING "core_examattempt"."id"'
params = (1, 1, None, 'COURSE', 0.0, None, ...)

    def execute(self, query, params=None):
        if params is None:
            return super().execute(query)
        # Extract names if params is a mapping, i.e. "pyformat" style is used.
        param_names = list(params) if isinstance(params, Mapping) else None
        query = self.convert_query(query, param_names=param_names)
>       return super().execute(query, params)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       django.db.utils.IntegrityError: NOT NULL constraint failed: core_examattempt.correct_count

C:\Python313\Lib\site-packages\django\db\backends\sqlite3\base.py:359: IntegrityError
=========================== short test summary info ===========================
FAILED core/tests/test_models.py::TestCoreModels::test_question_creation - Ty...
FAILED core/tests/test_models.py::TestCoreModels::test_exam_attempt_logic - d...
FAILED core/tests/test_models.py::TestCoreModels::test_exam_answer_creation
FAILED core/tests/test_views.py::TestExamAttemptViewSet::test_list_exams_authenticated
FAILED core/tests/test_views.py::TestExamAttemptViewSet::test_create_exam_attempt
FAILED core/tests/test_views.py::TestExamAttemptViewSet::test_retrieve_exam_with_missing_data_safe
======================== 6 failed, 2 passed in 10.67s =========================
